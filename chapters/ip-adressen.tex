\chapter{IP-adressen}

Een IP-adres is een 32-bit getal en heeft dus een waarde tussen 0 en \num{4294967296}.
Dit is echter geen handige manier om met IP-adressen om te gaan dus noteren we deze getallen op een andere manier.
We verdelen de 32~bits in vier groepjes van 8~bits,%
   \footnote{%
      Een groep van 8~bits wordt ook wel een \emph{octet} genoemd of een \emph{byte}.
      Deze laatste term is echter niet helemaal correct want een byte kan ook meer of minder bits bevatten dan acht.
      Dit is afhankelijk van de computerarchitectuur.
      Voor een x86-computer bevat een byte inderdaad acht bits, maar voor bijvoorbeeld de iconische PDP-7\footnotemark\ 
      bevat een byte achttien bits.
   }%
   \footnotetext{De PDP-7 is iconisch omdat het de computer is waar Unics op ontwikkeld werd.}
vertalen deze vier groepjs van binair naar decimaal en plaatsen een punt tussen deze groepjes.

\begin{verbatim}
1010 1100   0001 1000   0000 1100   1110 0001 = 2 887 257 313

1010 1100 . 0001 1000 . 0000 1100 . 1110 0001

   172    .     24    .     12    .    225
\end{verbatim}

Het Internet Protocol (IP) wordt gebruikt voor communicatie tussen computers die zich op verschillende netwerken bevinden.
Een IP-adres bestaat dan ook uit twee delen: een netwerkgedeelte dat voor elk netwerk uniek is, en een hostgedeelte dat binnen een netwerk uniek is voor elk toestel.
Dit kan je vergelijken met een gewoon adres.
Deze bevat een gemeente, straatnaam en huisnummer.
Binnen een gemeente moet elke straatnaam uniek zijn en binnen de straat moet elk huisnummer uniek zijn.

Als we naar bovenstaand IP-adres kijken, is het echter niet duidelijk welk deel het netwerk aanduidt en welk deel de host binnen dat netwerk uniek identificeert.
Daar hebben we extra informatie voor nodig in de vorm van een \emph{prefix length} of een \emph{subnet mask}.
Dat was echter niet altijd het geval.

In 1980 geloofde men nog niet dat er veel computernetwerken zouden zijn en hanteerde men de eenvoudige regel dat het eerste octet aangeeft tot welk netwerk het IP-adres behoort, en de laatste drie octets bepalen de computer binnen het netwerk.
De computers met IP-adres 10.0.7.23 en 10.12.4.18 behoren dus tot hetzelfde netwerk omdat voor beide het eerste octet dezelfde waarde heeft~(10).
De computers met IP-adres 10.0.7.23 en 23.9.102.123 behoren echter \emph{niet} tot hetzelfde netwerk omdat het eerste octet verschillend is.

Men kwam er al snel achter dat 256%
   \footnote{De netwerken 0 en 255 werden niet gebruikt omdat de IP-adressen 0.0.0.0 en 255.255.255.255 een specialie betekenis hebben dus het maximum was eigenljk maar 254 netwerken.}
netwerken toch te weinig is dus al in 1981 werd deze regel aangepast en werden er drie \emph{klasses} gedefiniëerd.
De IP-adressen die beginnen met 0 t.e.m.~127 behoorden tot klasse \emph{a} en hiervoor geldt de reeds bestaande regel: het netwerk wordt gekenmerkt door het eerste octet.

De IP-adressen die beginnen met 128 t.e.m.~191 behoren tot klasse \emph{b}. Hier voor geldt een nieuwe regel.
Hier bepalen de eerste twee octetten het netwerkgedeelte en de laatste twee worden gebruikt om elke computer binnen het netwerk uniek te identificeren.
De IP-adressen 131.12.237.182 en 131.12.1.4 behoren dus tot hetzelfde netwerk maar 131.93.12.3 behoort tot een ander netwerk.

De derde klasse, klasse \emph{c}, bevat de IP-adressen die beginnen met 192 t.e.m.~223.
Voor deze klasse geldt dat de eerste drie octetten het netwerk aanduiden en enkel het laatste octet gebruikt wordt om een computer binnen het netwerk aan te duiden.

Dit resulteert in drie soorten netwerken met elk enorme verschillen qua grootte.
Netwerken uit klasse a hebben voldoende IP-adressen voor meer dan 16 miljoen computers in één netwerk.
Netwerken uit klasse b kunnen meer dan \num{65000} computers huisvesten en netwerken uit klasse c ``slechts'' 256 computers.%
   \footnote{In feite kunnen er maar 254 computers in zo een netwerk geplaatst worden omdat er altijd twee IP-adressen gereserveerd zijn als \emph{netwerkadres} en \emph{broadcastadres}.}



\section{Speciale IP-adressen}
\label{sec:speciale-ip-adressen}

Elk netwerk bevat twee speciale IP-adressen die niet gebruikt kunnen worden voor computers of andere toestellen.
Het allereerste IP-adres in het netwerk is het \emph{netwerkadres} en doet dienst als de naam van het netwerk.
Het allerlaatste IP-adres in het netwerk is het \emph{broadcastadres} en kan door computers gebruikt worden om te communiceren met alle toestellen binnen dat netwerk.





\section{Subnetting}
\label{sec:subnetting}

In 1993 werd \emph{subnetting} ingevoerd als manier om deze grote netwerken onder te verdelen in kleinere netwerken zodat er minder verspilling is van IP-adressen.
Sinds 1995 werd dit subnetting veralgemeend en werden de klasses afschaft.
Nu kan er voor elk netwerk de juiste grootte bepaald worden.

Subnetting introduceert het concept van een \emph{subnet mask} om duidelijk te maken welk deel van het IP-adres voor het netwerk gebruikt wordt en welk deel gebruikt wordt voor de identificatie van de host.
Later wordt ook de \emph{prefix length} gebruikt om dezelfde informatie weer te geven.
Uit het subnet mask kan je dus de prefix length afleiden en omgekeerd, als je de prefix length hebt, kan je ook eenvoudig het subnet mask bepalen.

De \emph{prefix length} is een getal dat aangeeft hoeveel bits -- van links te beginnen -- gebruikt worden voor het netwerkgedeelte.
Voor een IP-adres uit klasse~a is de prefix length~8: het eerste octet (8~bits) bepaalt het netwerk.
Voor een IP-adres uit klasse~b is de prefix length~16 want de eerste twee octets ($2\times 8=16$) bepalen het netwerk.
Tot slot hebben IP-adressen behorend tot klasse~c een prefix length van~24.

Een \emph{subnet mask} heeft de vorm van een IP-adres.
Het bestaat uit 32~bits, opgedeeld in vier blokjes van 8~bits.
Vanaf links te beginnen, bestaat het uit een reeks eentjes gelijk aan de prefix length, gevolgd door nullen tot het totaal 32~bits bevat.
Het subnet mask van een klasse~a-adres is dus 255.0.0.0 (acht keer een 1 gevolgd door $32-8=24$ keer 0).
Het wordt, net zoals een IP-adres, geschreven als vier blokjes van 8~bits, van elkaar gescheiden met puntjes.
Klasse~b en~c-adressen hebben respectievelijk een subnet mask van 255.255.0.0 (16 keer 1, gevolgd door 16 keer~0) en 255.255.255.0 (24 keer 1, gevolgd door 8 keer 0).

Nemen we 192.168.0.0/24 als voorbeeld.
De prefix length is 24 dus het subnet mask bestaat uit een reeks van 24 éénen gevolgd door $32-24=8$ nullen, ofwel 255.255.255.0.
Dit betekent dat de eerste drie octetten gebruikt worden voor het netwerk en het vierde octet voor de identificatie van de computers binnen het netwerk.
Het allereerste IP-adres in het netwerk is 192.168.0.0; dit is het netwerkadres.
Het allerlaatste IP-adres is 192.168.0.255; dit is het broadcastadres.

\emph{Subnetting} is het onderverdelen van een netwerk in kleinere netwerken, vandaar de naam ``subnetwerken.''
Maar het is correcter om te zeggen dat subnetting een blok van aaneensluitende IP-adressen onderverdeeld is verschillende, even grote stukken.
Hierbij moeten we er altijd aan denken dat IP-adressen voor de computer binaire getallen zijn en alles dus met veelvouden van twee gebeurt.

Met subnetting kunnen we een willekeurige waarde kiezen voor de prefix length in plaats van enkel maar 8, 16, of~24, zoals het geval is met de klasses a, b, en c.
Nemen we opnieuw het netwerkadres 192.168.0.0 als voorbeeld, maar dit keer met een prefix length van~26 in plaats van~24.
Het subnet mask bestaat nu uit een reeks van 26 éénen gevolgd door $32-26=6$ nullen, ofwel 255.255.255.192.
Het eerste IP-adres in het netwerk is nog steeds 192.168.0.0;
maar het laatste IP-adres in het netwerk is nu 192.168.0.63.

Dit kunnen we op twee manieren verklaren.
Omdat er nog maar 6~bits over blijven om computers uniek te identificeren, hebben we $2^6=64$ mogeljkheden.
Dit zijn dus de IP-adressen van 192.168.0.0 t.e.m. 192.168.0.63.

Een tweede manier om dit te bekijken, is dat er 256 mogelijke IP-adressen zijn in het netwerk als de prefix length~24 is.
Als we de prefix length verhogen naar 26, gebruiken we twee bits extra om het netwerk uniek te identificeren.
Deze twee bits geven vier combinaties (00, 01, 10 en 11).
De 256~IP-adressen worden dus opgedeeld in vier gelijke delen:

\[\frac{256}{4} = 64\]

Deze vier subnetwerken hebben elk een netwerkadres en een broadcastadres.
Deze worden weergegeven in \vref{tab:subnet-voorbeeld}.
Merk op dat de netwerkadressen steeds met een sprong van 64 omhoog gaan.
Dit is een logisch gevolg van het feit dat elk subnetwerk even groot is en elk subnetwerk 64~IP-adressen bevat.
Deze sprong zie je trouwens ook terug bij de broadcastadressen ($63 + 64 = 127$).

\begin{table}[htp]
   \centering
   %\libertineTabular
   \begin{tabular}{rll}
   \textit{bits} & \textit{netwerkadres}     & \textit{broadcastadres} \\[1ex]
   \textit{00}   & 192.168.0.0/26   & 192.168.0.63   \\
   \textit{01}   & 192.168.0.64/26  & 192.168.0.127  \\
   \textit{10}   & 192.168.0.128/26 & 192.168.0.191  \\
   \textit{11}   & 192.168.0.192/26 & 192.168.0.255  \\
   \end{tabular}
   \caption{Een netwerk met prefix length 24 wordt onderverdeeld in vier subnetwerken van gelijke grootte}
   \label{tab:subnet-voorbeeld}
\end{table}

Elk (sub)netwerk kan je op zijn beurt weer onderverdelen in kleinere netwerken.
Dit wordt dan \emph{variable length subnet mask} (VLSM) genoemd.
Elk netwerk kan op die manier op maat gemaakt worden van het aantal toestellen dat er in moeten.
Je moet hierbij wel onthouden dat de grootte van een netwerk steeds een factor van twee moet zijn.
Met een prefix length van 26 bevat het netwerk 64~IP-adressen.
Als de prefix length 25 is, bevat het netwerk 128~IP-adressen.
Met een prefix length van 24, is dat weer een factor twee groter, ofwel 256~IP-adressen.

\Vref{fig:vlsm} toont het opdelen van een blok van 256~IP-adressen in kleinere netwerken op een grafische manier.


\begin{figure}[hbp]
   \centering
   \begin{tikzpicture}
      \pie[sum = auto,
           color = {
              spot1,
              spot1!66,
              spot2,
              spot3!40,
              spot3!20,
              spot1!33
           }
         ]{64/{192.168.0.0/26},
           64/{192.168.0.64/26},
           32/{192.168.0.128/27},
           16/{192.168.0.160/28},
           16/{192.168.0.176/28},
           64/{192.168.0.192/26}}
   \end{tikzpicture}
   \caption{Met VLSM kan je een blok IP-adressen opdelen is verschillende kleinere subnetten van verschillende groottes}
   \label{fig:vlsm}
\end{figure}



\section{Dynamic Host Configuration Protocol (DHCP)}
\label{sec:dhcp}

Gewone computergebruikers weten niets af van IP-adressen, subnet masks of \emph{default gateways}.\footnote{Zie \vref{chap:routing}.}
Dit komt omdat computers dit allemaal automatisch configureren.
Stel je maar eens voor dat je met je laptop naar het werk gaat en eerst moet bellen naar de helpdesk om te vragen welke IP-instellingen je moet ingeven op je laptop.
Vervolgens moet je naar een klant en ook daar moet je eerst naar de helpdesk bellen om de juiste gegevens op te vragen.
Thuis moet je weer je instellingen aanpassen op de laptop.

Er was een tijd wanneer je voor elke nieuwe computer naar de helpdesk moest bellen om de juiste IP-instellingen door te krijgen.
De helpdesk had eerst een waslijst aan vragen die je moest beantwoorden, zoals\footnote{Zie \cite[4]{droms02}.}
\begin{itemize}
\item Wie ben je?
\item Is het een nieuwe computer of was deze computer al eerder met het netwerk verbonden?
\item Indien deze computer al eerder met het netwerk verbonden was, welk IP-adres had het toen?
\item Waar wil je de computer installeren?
\item Voor welke afdeling werk je?
\end{itemize}

Het \emph{dynamic host configuration protocol} (DHCP) is een protocol dat in vier eenvoudige stappen zorgt dat een netwerkdevice een geldig IP-adres krijgt.
Het protocol kan de computer ook voorzien van andere informatie, bijvoorbeeld
\begin{itemize}
\item
   Telefoontoestellen kunnen via DHCP het IP-adres of de domeinnaam van de telefooncentrale opvragen.
\item
   Wireless access points kunnen het IP-adres van de wireless LAN controller (WLC) bekomen met DHCP.
\item
   Thin clients of computers kunnen via DHCP de nodige informatie bekomen om via het netwerk op te starten.
   Ze beschikken dus niet over een interne harde schijf met een besturingssysteem maar downloaden het volledige besturingssysteem en hun configuratie via PXE.
   Al de nodige informatie voor een PXE-boot kan via DHCP bekomen worden.
\end{itemize}

De vier stappen die het protocol doorloopt, zijn
\begin{description}
\item[discover]
   Een computer verstuurt een \emph{discover} pakketje tijdens de opstartprocedure en het initialiseren van de netwerkconfiguratie.
   Omdat de computer nog geen IP-adres heeft en niet weet binnen welk netwerk hij zich bevindt, verstuurt hij deze dsicover als een \emph{broadcast} naar het speciale broadcastadres 255.255.255.255.
   Alle DHCP-servers binnen het lokale netwerk ontvangen dit bericht en kunnen antwoorden met een \emph{offer}.
\item[offer]
   Een DHCP-server die een discover pakketje ontvangt, kan antwoorden met een \emph{offer} waarin hij de client een voorstel doet.
   Dit voorstel bevat sowieso een IP-adres, een subnet mask en een leaseperiode hoe lang de client dit IP-adres mag blijven gebruiken.
   De offer kan echter ook nog verschillende andere opties bevatten, zoals
   \begin{itemize}
   \item de default gateway die de client moet gebruiken om te communiceren met computers die zich in andere netwerken bevinden;
   \item een of meerdere DNS-servers die de client kan gebruiken om domeinnamen om te zetten in IP-adressen;
   \item het IP-adres of de domeinnaam van een WLC;
   \item het IP-adres of de domeinnaam van de telefooncentrale;
   \item een TFTP-server vanwaar de client een besturingssysteem (PXE-boot) of een configuratiebestand kan downloaden.
   \end{itemize}
\item[request]
   De coputer kan van meerdere DHCP-servers een offer ontvangen maar heeft er slechts één nodig.
   Hij maakt dus een keuze uit alle beschikbare offers en vraagt via een request om één van deze offers te gebruiken.
\item[acknowledge]
   De DHCP-server bevestigt dat de reservatie in orde is.
\end{description}

Initiëel gebeuren deze vier pakketjes via broadcast naar het speciale broadcastadres 255.255.255.255.
Echter als de lease half om is, kan de client deze lease verlengen door een request te versturen naar de DHCP-server.
Dit kan via unicast gebeuren naar het IP-adres van de DHCP-server van wie de client de offer heeft gekozen.
De acknowledge van die DHCP-server gebeurt dan ook via unicast.

Al deze broadcast blijven binnen het lokale netwerk.
Moest een router deze doorsturen naar andere netwerken, het hele Internet zou vol lopen met zinloze broadcasts.
Dit betekent dat elk netwerk een DHCP-server moet hebben die kan antwoorden op deze discover-berichten van de clients.
Het is echter niet handig om zo veel DHCP-servers te moeten beheren, verspreid over het gehele netwerk.
In het ideale geval, heb je maar een paar centrale servers waar je alle IP-adresbeheer doet.

Je kan de \emph{default gateway} -- de router die het netwerk van andere netwerken verbindt -- configureren als een DHCP \emph{relay}.
Deze DHCP relay luistert op het netwerk naar DHCP discover of request pakketjes van clients en stuurt die door naar de IP-adressen van de geconfigureerde DHCP-servers.
De antwoorden die de relay ontvangt van de DHCP-server zet hij weer om in een broadcast dewelke hij op het lokale netwerk verstuurt.
Dit laat toe om met slechts enkele (minstens twee voor redundantie) DHCP-servers meerdere netwerken te voorzien van IP-adressen op een dynamische manier en om de gehele IP-informatie op een centrale lokale te beheren.




\section{Network address translation (NAT)}
Er zijn in totaal ongeveer 4,3~miljard IPv4-adressen maar ongeveer dertien procent of 560~miljoen IP-adressen (klasse~d en~e) kunnen niet gebruikt worden.
Dit geeft ons 3,7~miljard IPv4-adressen of ongeveer één IPv4-adres voor elke twee mensen op aarde.
Aangezien elke westerling minstens drie IP-adressen nodig heeft -- een voor de laptop, een voor zijn gsm en een voor de tabelet -- hebben we minstens zes keer te weinig IPv4-adressen.

Er werden twee oplossingen bedacht voor dit tekort aan IP-adressen:
in 1994 werd \emph{network address translation} (NAT) geïntroduceerd en in 1998 werden de eerste documenten opgesteld over IPv6.
NAT maakt gebruik van de RFC\,1918-adressen\footnote{Deze werden al benoemd in RFC\,1597 in het jaar 1994.} ofwel de ``private'' IP-adressen (\vref{tab:rfc1918}).
Dit zijn IP-adressen die voorbehouden zijn voor computers die enkel op het interne netwerk willen communiceren en geen connecties opzetten met het Internet.

Aangezien alle bedrijven deze IP-adressen kunnen gebruiken voor hun interne netwerken, zijn deze IP-adressen niet uniek.
Ze kunnen dan ook niet gebruikt worden op het Internet.
Met behulp van \emph{network address translation} (NAT) kan een router of firewall deze private IP-adressen omzetten in een publiek IP-adres zodat de interne computer toch met computers op het Internet kan communiceren.


\begin{table}[htp]
   \centering
   \begin{tabular}{lllr}
   \textit{netwerk}  & \textit{eerste IP-adres} & \textit{laatste IP-adres} & \textit{aantal IP-adressen}\\[1ex]
   10.0.0.0/8        & 10.0.0.0                 & 10.255.255.255            & \num{16777216} \\
   172.16.0.0/12     & 172.16.0.0               & 172.31.255.255            & \num{1048576}  \\
   192.168.0.0/16    & 192.168.0.0              & 192.168.255.255           & \num{65536}    \\
   \end{tabular}
   \caption{De RFC\,1918-adressen voor intern gebruik}
   \label{tab:rfc1918}
\end{table}


Er zijn drie manieren om private IP-adressen te vertalen naar publieke IP-adressen die gebruikt kunnen worden op het Internet.
\begin{enumerate}
\item
   Er kan een statische één-op-éénvertaling gebruiken tussen private en publieke IP-adressen.
   Als vijf computers met private IP-adressen willen communiceren met het Internet, zijn ook vijf publieke IP-adressen nodig.
   Deze methode van NAT doet niets om het tekort aan IP-adressen te voorkomen en lijkt ook weinig nuttig.
   Dit wordt toegepast voor servers die intern wel een privaat IP-adres gebruiken maar die op het Internet een uniek publiek IP-adres willen hebben.
   Deze methode kan ook gebruikt worden als verschillende bedrijven rechtstreeks met elkaar willen communiceren maar overlappende IP-adressen gebruiken.
\item
   Alle interne computers die connecteren met een toestel op het Internet, krijgen een publiek IP-adres toegewezen uit een pool van beschikbare adressen.
   Is deze pool bijvoorbeelde de reeks 192.0.2.16/29, dan zal de eerste interne computer die een verbinding opbouwt met een host op het Internet, het IP-adres 192.0.2.16 krijgen;
   de tweede computer krijgt het IP-adres 192.0.2.17 en zo verder.
   Als de eerste computer gedaan heeft met communiceren, kan zijn publiek IP-adres terug vrijgegeven worden aan de pool en dienen voor een volgende machine.
   Als alle IP-adressen uit de pool in gebruik zijn, dan kunnen er geen interne computers meer communiceren met hosts op het Internet.
\item
   De derde methode is een verbetering van de tweede methode en kijkt niet alleen naar de source en destination IP-adressen, maar neemt ook de source en destination poortnummers in rekening.
   Stel twee interne computers willen beide een webserver bereiken met IP-adres 203.0.113.25.
   De interne computers hebben respectievelijk de IP-adressen 10.0.1.7 en 10.0.1.8 en kiezen beide toevallig dezelfde source poort 7200.
   De router vertaalt beide private IP-adressen naar het publieke IP-adres 192.0.2.16 maar dan zouden beide flows niet meer uniek zijn.
   \begin{center}
   \begin{tabular}{lll}
   \textit{source intern} & \textit{source extern} & \textit{destination} \\[1ex]
   10.0.1.7:7200          & 192.0.2.16:7200        & 203.0.113.25:443 \\
   10.0.1.8:7200          & 192.0.2.16:7200        & 203.0.113.25:443 \\
   \end{tabular}
   \end{center}
   Als de webserver een antwoord terug stuurt naar het publieke IP-adres 192.0.2.16, kan de router op geen enkele manier bepalen op de pakketjes voor de eerste of de tweede host zijn.
   Op dit op te lossen, verandert de router niet alleen het source IP-adres maar ook de source poort.
   Voor deze laatste wordt een random waarde gekozen die nog niet in gebruik is.
   \begin{center}
   \begin{tabular}{lll}
   \textit{source intern} & \textit{source extern} & \textit{destination} \\[1ex]
   10.0.1.7:7200          & 192.0.2.16:3034        & 203.0.113.25:443 \\
   10.0.1.8:7200          & 192.0.2.16:6201        & 203.0.113.25:443 \\
   \end{tabular}
   \end{center}
   Deze methode heet \emph{port-based address translation} (PAT) of \emph{network address and port translation} (NAPT).
\end{enumerate}



\section{Address resolution protocol (ARP)}
\label{sec:arp}

Twee computers op hetzelfde lokale netwerk, willen met elkaar communiceren.
In \vref{fig:transmit-data} hebben we gezien dat elk pakketje behalve poortnummers en IP-adressen, ook MAC-adressen nodig heeft om op laag~2 te kunnen communiceren (zie ook \vref{sec:ethernet}).
We kunnen de volgende informatie te weten komen:
\begin{description}
\item[destination poort]
   Elke applicatie server luistert op een welgekende, vastgelegde poort.
   Een webserver luister op poort 80 voor unencrypted verkeer (HTTP) en op poort 443 als het verkeer encrypted is (HTTPS).
   Een mailserver luistert op poort 25 en een MySQL database op poort 3306.
\item[source poort]
   De client kiest een willekeurige poortnummer die uniek moet zijn voor elke communicatiesessie die de client opzet.
\item[source IP-adres]
   De computer kent logischerwijs zijn eigen IP-adres dat ofwel statisch (manueel) werd ingegeven of via DHCP werd verkregen.
\item[destination IP-adres]
   Als je een dienst wilt gebruiken, moet je ofwel het IP-adres kennen van de server, ofwel gebruik maken van DNS om een domeinnaam om te zetten in een IP-adres.
\item[source MAC-adres]
   Dit is het unieke adres van je netwerkkaart en is dus gekend voor de client.
\end{description}
De enige informatie die nog ontbreekt, is het destination MAC-adres.
Om deze informatie te weten te komen, wordt het address resolution protocol (ARP) gebruikt.
De client stuurt via een broadcast een ARP request op het lokale netwerk met de vraag ``wie heeft dit IP-adres en wat is jouw MAC-adres?''
De server ontvangt deze broadcast en antwoord met een ARP reply (ook broadcast).
Dit antwoord bevat zijn IP-adres en zijn MAC-adres.
Nu heeft de client alle nodige informatie om het pakketje te verzenden.

Omdat deze ARP-pakketjes via broadcast verstuurd worden, kunnen enkel computers op het lokale netwerk deze ontvangen.
Een router stuurt deze broadcasts niet door naar andere netwerken dus bovenstaande methode is niet geschikt als een computer wil communiceren met een computer op een ander netwerk.
Dit is een probleem want er moet toch een destination MAC-adres ingevuld worden voor elk pakketje dat je verstuurd.